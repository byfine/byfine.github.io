---
layout: post
title: AI：Behavior Tree 行为树
description: "Behavior Tree 行为树 简介"
modified: 2016-01-22
tags: [Unity3D, AI]
---

Behavior Tree (BTs)，在许多3A游戏中都有广泛应用。之前我们已经简单介绍过它，希望你先看一下。这篇我们来更为详细地介绍一下行为树。

### 行为树的基本概念
之所以称为树，是因为它是多个节点(Nodes)的分层、分支系统，这些节点共有一个根(Root)。如果我们图像化行为树，它看起来会像这样：

![]({{ site.url }}/images/post/Unity-AI/BTS-1.png)

当然，行为树可以由任意数量的节点及子节点构成。在分层最后的节点被称为叶节点，就像真实的树一样。节点可以表示行为或测试。不像状态机有转换规则贯穿其中，一个行为树的流程是由更上层节点的顺序严格定义的。一个行为树是从树的顶点开始评估的，然后继续按顺序遍历每个子节点，直到遇到特定条件或者到达叶节点。行为树总是从根节点开始评估。

### 不同节点类型
不同类型节点的名称可能会根据情况有所变化，甚至节点自身有时也被称作 任务。然而一个树的复杂度完全取决于AI的需求，关于行为树如何工作的更高级概念，如果我们只关注每个独立的部分就会非常容易理解。接下来的概念对于不管什么类型的节点都是适用的，一个节点总会返回下面其中一个状态：
    
- **Success**：遇到了节点要检查的条件。
- **Failure**：没有且不会遇到节点要检查的条件。
- **Running**：节点检查的条件的有效性还未确定，可以认为是“请等待”状态。

由于行为树潜在的复杂性，大部分实现都是异步的，即评估一个行为树并不会阻塞其他操作。如果必要的话，一个树中的各种节点的评估过程可能会经过好几帧。如果你要同时检测好几个行为树，可以想象这会影响程序的性能，来等待它们每一个树都返回一个True或False到根节点。这也是“Running”状态存在的重要性。

#### 定义复合节点
之所以称作复合节点是因为它们有一个或更多子节点。它们的状态取决于它们子节点的结果，并且当其子节点正被评估，它们就处于“Running”状态。有许多复合节点类型，一般由它们的子节点如何评估来定义：

- **Sequences（序列）**：序列的特点是，所有子节点的序列都需要按顺序成功完成，才能被评估为成功。如果序列中在任一步有任一子节点返回flase，那这个序列都被视作失败。需要注意，通常序列顺序都是从左到右，下图显示了成功的序列和失败的序列：
  
    ![]({{ site.url }}/images/post/Unity-AI/BTS-2.png)
    
- **Selectors（选择器）**：相对来说，选择器对于它们的子节点来说是更“宽容”的父节点。任何一个子节点返回True，选择器都马上被认为是True，并不再评估其他子节点。选择器唯一会返回False的情况，就是所有子节点都被评估并且都返回False。

每个复合节点类型都有适用的情况，你可以把它们看作“与”和“或”。

#### 理解修饰节点
修饰节点和复合节点最大的不同是，修饰节点只能有一个子节点。也许你认为这样没有必要，但修饰节点比较特殊，本质上它们接收子节点返回的结果，并根据自身的参数来决定如何回应。一个修饰节点甚至可以指示如何评估以及多久评估一次它们的子节点。这是一些常见的修饰节点类型：

- **Inverter（反转器）**：可以认为是“非”修饰符。它会反转子节点返回的结果。
- **Repeater（重复器）**：会重复评估子节点特定的（或无穷）次数，直到子节点返回修饰节点决定的True或False。比如你会无限等待直到遇到某一特定情况。
- **Limiter（限制器）**：限制一个节点执行的次数，以避免陷入循环。这与Repeater形成对比，可以用于某一角色只会尝试一定次数，然后就会放弃。

还有一些修饰节点是用来调试和测试行为树的，比如：

- **Fake state**：根据修饰节点指定总会返回True或False。这对于断言特定行为很有用。你也可以使修饰节点一直保持“Running”状态，以观察周围其他节点的行为。
- **Breakpoint**：就像代码中的断点，可以切断逻辑，并指示你节点已到达。

这些类型并不是互相排斥的单一类型。你可以组合这些节点类型以适应你的需求。只是要注意不要组合过多的功能到一个修饰器，也许那样的效率或方便程度还不如使用序列来代替。

#### 描述叶节点
我们之前介绍叶节点是行为树结构的一点，但其实叶节点可以是行为的任何形式。它们可以描述你的角色拥有的任何形式的逻辑。一个叶节点可以描述一个行走函数，射击命令，或攻击行为等。它做什么或如何评估状态并不重要，它只是自身层级的最后一个节点，并且返回三个状态中的一个。



